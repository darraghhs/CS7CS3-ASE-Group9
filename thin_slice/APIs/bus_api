"""
Dublin Bus Route 39A Tracker
Uses the GTFS-R API from https://developer.nationaltransport.ie/
#https://bustimes.org/operators/dublin-bus/vehicles
"""

import requests
from datetime import datetime
import random, csv, time

# Your API key from developer.nationaltransport.ie
API_KEY = "1fea1c21bef840e6bf0241e34a41e5d8"  # Replace with your actual API key
BASE_URL = "https://api.nationaltransport.ie/gtfsr/v2"

# -------------------------------------------------------
# 1. Look up correct GTFS route_id for route_short_name
# -------------------------------------------------------
def get_route_id_from_short_name(short_name, routes_file="routes.txt"):
    with open(routes_file, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            if row["route_short_name"].strip().upper() == short_name.upper():
                return row["route_id"]
    return None

# -------------------------------------------------------
# 2. Only return *real live buses* based on trip_updates
# -------------------------------------------------------
def get_realtime_active_trips(route_id):
    url = f"{BASE_URL}/TripUpdates?format=json"
    headers = {"x-api-key": API_KEY, "Accept": "application/json"}

    response = requests.get(url, headers=headers, timeout=10)
    response.raise_for_status()
    data = response.json()

    now = int(time.time())
    active = []

    for entity in data.get("entity", []):
        trip_update = entity.get("trip_update", {})
        trip = trip_update.get("trip", {})

        if trip.get("route_id") != route_id:
            continue

        stop_updates = trip_update.get("stop_time_update", [])
        if not stop_updates:
            continue

        # Find the nearest future stop with real-time info
        future_stops = []
        for u in stop_updates:
            arrival_time = u.get("arrival", {}).get("time")
            departure_time = u.get("departure", {}).get("time")
            if arrival_time or departure_time:
                future_stops.append(u)

        if not future_stops:
            continue

        next_stop = future_stops[0]

        # Choose arrival or departure timestamp
        rt_time = (
            next_stop.get("arrival", {}).get("time")
            or next_stop.get("departure", {}).get("time")
        )

        if isinstance(rt_time, str):
            try:
                rt_time = int(rt_time)
            except ValueError:
                continue

        if rt_time is None:
            continue

        # Calculate delay (may be None ‚Üí treat as on-time)
        delay = (
            next_stop.get("arrival", {}).get("delay")
            or next_stop.get("departure", {}).get("delay")
            or 0
        )
        minutes_due = max(0, (rt_time - now) // 60)

        # Determine status
        if delay <= 60:
            status = "On Time"
        elif delay <= 180:
            status = "Slight Delay"
        else:
            status = "Late"

        active.append({
            "route": route_id,
            "destination": trip.get("trip_headsign", "Unknown"),
            "rt_time": rt_time,
            "minutes_due": int(minutes_due),
            "delay": delay,
            "status": status
        })

    return active

# -------------------------------------------------------
# 3. Display arrivals
# -------------------------------------------------------
def display_bus_arrivals(route_short, buses):
    print("\n" + "=" * 80)
    print(f"üöå LIVE BUSES ‚Äî ROUTE {route_short}")
    print("=" * 80)
    print(f"Current Time: {datetime.now().strftime('%H:%M:%S')}\n")

    if not buses:
        print("‚ùå No live buses found")
        return

    for i, b in enumerate(buses, start=1):
        icon = "‚úì" if b["status"] == "On Time" else ("‚ö†Ô∏è" if "Slight" in b["status"] else "‚ùå")
        print(f"{i}.{route_short}  ‚Üí {b['destination']}")
        print(f"   Status: {icon} {b['status']}")
        print(f"   Due in: {b['minutes_due']} min")
        print(f"   Delay: {b['delay']} seconds")
        print()

    print("=" * 80 + "\n")

# -------------------------------------------------------
# 4. On-time performance analysis
# -------------------------------------------------------
def display_on_time_analysis(route_short, buses):
    """
    Display % of buses running on time, with simple summary.
    """
    if not buses:
        print("‚ùå No buses to analyze")
        return

    total = len(buses)
    on_time = sum(1 for b in buses if b["status"] == "On Time")
    slight = sum(1 for b in buses if "Slight" in b["status"])
    late = sum(1 for b in buses if "Late" in b["status"])

    on_time_pct = (on_time / total) * 100

    print("\n" + "=" * 80)
    print(f"üìä ROUTE {route_short} ‚Äî LIVE ON-TIME ANALYSIS")
    print("=" * 80)
    print(f"Total buses tracked: {total}")
    print(f"‚úì On Time: {on_time} buses ({on_time_pct:.1f}%)")
    print(f"‚ö†Ô∏è  Slight Delay: {slight} buses ({slight/total*100:.1f}%)")
    print(f"‚ùå Late: {late} buses ({late/total*100:.1f}%)\n")

    if on_time_pct >= 80:
        print(f"‚úì GOOD - Route {route_short} is running well ({on_time_pct:.1f}% on-time)")
    elif on_time_pct >= 60:
        print(f"‚ö†Ô∏è  FAIR - Route {route_short} has some delays ({on_time_pct:.1f}% on-time)")
    else:
        print(f"‚ùå POOR - Route {route_short} has significant delays ({on_time_pct:.1f}% on-time)")

    print("=" * 80 + "\n")

# -------------------------------------------------------
# MAIN
# -------------------------------------------------------
if __name__ == "__main__":
    route_short = "G2"

    print("\nüîç Loading route_id from routes.txt...\n")
    route_id = get_route_id_from_short_name(route_short)

    if not route_id:
        print(f"‚ùå Could not find GTFS route_id for route {route_short}")
        exit()

    print(f"‚úì Route {route_short} maps to GTFS route_id: {route_id}\n")
    print("üì° Fetching real-time bus updates...\n")

    try:
        buses = get_realtime_active_trips(route_id)
        # Sort by soonest arrival
        buses.sort(key=lambda x: x["minutes_due"])
        display_bus_arrivals(route_short, buses)
        display_on_time_analysis(route_short, buses)

    except Exception as e:
        print(f"‚ùå Error fetching data: {e}")
